import time
import uuid
import requests
from django.core.files.base import ContentFile
from django.core.files.storage import Storage
from django.conf import settings
from django.utils.deconstruct import deconstructible
import cloudinary
import cloudinary.uploader
import cloudinary.api

@deconstructible
class CloudinaryMediaStorage(Storage):
    """
    A custom Django storage backend that uploads files to Cloudinary using unique filenames
    and returns secure URLs.
    """
    def __init__(self, folder=None):
        # Use the provided folder or fallback to CLOUDINARY_FOLDER setting.
        self.folder = folder or getattr(settings, 'CLOUDINARY_FOLDER', '')
        # Configure Cloudinary using credentials from settings.
        cloudinary.config(
            cloud_name=getattr(settings, 'CLOUDINARY_CLOUD_NAME', None),
            api_key=getattr(settings, 'CLOUDINARY_API_KEY', None),
            api_secret=getattr(settings, 'CLOUDINARY_API_SECRET', None)
        )
    
    def _open(self, name, mode='rb'):
        """
        Retrieve a file from Cloudinary using its secure URL.
        """
        file_url = self.url(name)
        response = requests.get(file_url)
        if response.status_code != 200:
            raise IOError(f"Could not open file {name} from Cloudinary. Status code: {response.status_code}")
        return ContentFile(response.content)
    
    def _save(self, name, content):
        """
        Save a file to Cloudinary using a unique filename.
        The unique filename is generated by prepending a timestamp and a UUID to the original filename.
        """
        unique_name = f"{int(time.time())}_{uuid.uuid4().hex}_{name}"
        content.open()  # Ensure the file pointer is at the beginning.
        file_data = content.read()
        public_id = f"{self.folder}/{unique_name}" if self.folder else unique_name
        try:
            result = cloudinary.uploader.upload(
                file_data,
                public_id=public_id,
                overwrite=True
            )
        except Exception as e:
            raise Exception(f"Cloudinary upload error: {e}")
        # Return the public_id (this will be saved in the model field)
        return result.get("public_id", unique_name)
    
    def exists(self, name):
        """
        Always return False to force Django to call _save().
        """
        return False
    
    def url(self, name):
        """
        Return the secure URL for a file stored in Cloudinary.
        """
        try:
            result = cloudinary.api.resource(name)
            secure_url = result.get("secure_url")
            if not secure_url:
                raise Exception(f"Secure URL not found for file: {name}")
            return secure_url
        except cloudinary.api.Error as e:
            raise Exception(f"Error retrieving file {name}: {e}")
    
    def delete(self, name):
        """
        Delete a file from Cloudinary using its public_id.
        """
        try:
            cloudinary.uploader.destroy(name)
        except Exception as e:
            raise Exception(f"Cloudinary delete error: {e}")
    
    def size(self, name):
        """
        Return the size of the file.
        (Not implemented; extend if needed.)
        """
        return 0
    
    def get_available_name(self, name, max_length=None):
        """
        Since _save() always generates a unique filename, return the provided name.
        """
        return name
